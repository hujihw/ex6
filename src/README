omri.kaplan
etzion.asaf
gal.nachmana erez.levanon danielle.kutner ben.ella
ExpressionsDefiner.java               The class in charge of defining the S-Java expressions.
Finder.java                           In charge of finding variables and methods in the abstract compile tree.
ObjectDoesNotExistException.java      This is thrown by the Finder class if no object was found.
ObjectExistException.java             This is thrown by the Finder when trying to declare on an existing.
SyntaxErrorException.java             Thrown by the ExpressionDefiner if an expression is illegal.
UnInitLocalVarException.java          Thrown when trying to use a local variable that wasn't initialized.
VariableIsFinalException.java         Thrown when trying to assign a value to a final variable.
WrongParameterTypeException.java      Thrown when a wrong parameter type is given whn calling a method.
WrongProtocolDeclaration.java         Thrown when declaring a variable or a method with a wrong syntax.
BadFileException.java                 Thrown when trying to parse a file that does not exist or not text file.
BlockParser.java                      The class that does the parsing of code blocks (scopes).
MainParser.java                       This class parse the global scope.
Manager.java                          In charge of communicating with the different modules.
Sjavac.java                           The Main method is here.
UnclosedBlockException.java           Thrown when a block doesn't end with "}".
WrongArgumentsNumberException.java    Thrown when a wrong number of arguments is given to a method.
BlockFactory.java                     A factory for block objects (methods, if/while).
IfWhileBlock.java                     Represents an If/While block.
MainBlock.java                        Represents the global scope.
MethodBlock.java                      Represents a method block.
SuperBlock.java                       An abstract class that all blocks inherit.
VariableAlreadyExistException.java    Thrown when trying to declare a variable that already exists.
WrongParametersException.java         Thrown on method call when parameters doesn't match the method's.
SJavaException.java                   Every Exception inherit this class.
SJavaObject.java                      Every S-Java object inherit this class.
BooleanVar.java                       Represents a boolean variable.
CharVar.java                          Represents a character variable.
DoubleVar.java                        Represents a double variable.
FinalDecorator.java                   A decorator used for declaring variables as final.
IllegalVarException.java              Thrown when trying to create an unrecognized variable.
IntVar.java                           Represents a integer variable.
StringVar.java                        Represents a string variable.
SuperVar.java                         All of the variable classes inherit this class.
Type.java                             An Enum holding the variable types.
VarFactory.java                       A factory for variable objects.
QUESTIONS                             File with answered questions from the course staff.
README                                This file.

==========
= design =
==========

We were trying to keep the program as modular and extensible as possible, in order to allow future
expanding of the abilities and functions of it. We have used several design patterns to solve the problems
in this exercise: A factory pattern for the blocks and variables objects, in order to retain the single
choice and open/closed principles. A singleton design pattern for classes needed only one instance, but
also needed to hold data members. We used inheritance to have an hierarchy of S-Java objects (similar to
the idea of java objects), in order to keep several behaviors identical to all of the objects, and also
make it easier to expand the S-Java object types in the future. And we used a decorator for final variables
in order to keep the factory "dumb".

=========================
= implementation =
=========================

The Sjavac class called by a user with a .sjava file. The Manager is than called by the main method, and
call the main parser to parse the file. The parser sends non comment/empty lines to the ExpressionDefiner,
and that is where they are sent to the block factory/var factory or just being checked for validity. That's
how we get the global variables and methods declared in the global scope. The Manager then holds a MainBlock
object, returned from the parser, that represents the root of an abstract tree of hierarchy between the
different scopes, and holds the global scopes and variables. The manager then calls the block parser on
each method, and the process is pretty similar for every method, only now, the parsing is done recursively
and scopes (blocks) are created within each other, according to where they are declared.
Every error in the code is followed by the appropriate exception and printing of "1".

========================
= answers to questions =
========================

Question from section 6.1:

We handle S-Java code errors with a system of exceptions. We have one general S-Java exception, which all
of the other exceptions inherit from. This way, we could fit the exceptions to our needs (giving the right
information about errors and printing informative messages), and also generalize the handling of exceptions
in the program (with polymorphism).
We chose to handle the errors this way because it is more intuitive (an error get an exception and not a
random int or boolean value), and also extensible (making it easier to add specific functionality to
certain errors and also group errors that require the same handling.)

Question from section 6.2:

* In order to add a new type of variable we need to add it to the saved words regex in ExpressionDefiner, add
a new class for that type, add this type to the Type enum, and add the name of the type to the VarFactory.

* In order to support an import feature, we'd add a method to the MainParser class that calls the main
parser on the imported file, and than add its methods and variables to the current mainBlock.

In order to support Unary and Binary operators, we'd add regex patterns to ExpressionDefiner that recognize
the operators, and a method in that class to handle each operator.

Question from section 6.3:

in general we found breaking down long regex to small strings very helpful both in code repetition reduction and
extensibility. we used string concatenation for that matter (the first String is the one we used and the second one is
 the concatenation result (brought here only for RexEg explanation- without java escape backslash).

String CALL_METHOD = "\\A\\s*(" + METHOD_NAME + ")\\s*\\(\\s*((" + VARIABLE_VALUE_OR_NAME +
            "(\\s*,\\s*" + VARIABLE_VALUE_OR_NAME + "\\s*)*" + ")|)\\)\\s*;\\s*\\z";


                     "\A\s*([a-zA-Z]\w*)\s*\(\s*(((true|false|".*"|'.'|-?\d+(\.\d+)?|_?[a-zA-Z]\w*)
            (\s*,\s*(true|false|".*"|'.'|-?\d+(\.\d+)?|_?[a-zA-Z]\w*)\s*)*)|)\)\s*;\s*\z"

explanation:
this regex matches the method call line expression as a whole.
we used in all of the "whole line match" RegEx's the \A \z bounders and also parentheses for grouping.
first we look for the method name which can include digits, letters and "_" but must start with a letter.
in the (double escaped) parentheses we look for a variable value or a variable name which can appear more that one with
a "," followed. the variable value can be true/false/string/char/int/double. a variable name can't start with a digit,
can start with "_" but must follow with any digit char or letter. the end of the line must be ";" (assuming all of the
parts can include zero or more white spaces).


String ASSIGN_VARIABLE = "\\A\\s*(" + VARIABLE_NAME + ")\\s*=\\s*" + VARIABLE_VALUE_OR_NAME +
            "\\s*;\\s*\\z";

            \A\s*(_?[a-zA-Z]\w*)\s*=\s*(true|false|".*"|'.'|-?\d+(\.\d+)?|_?[a-zA-Z]\w*)
            \s*;\s*\z

explanation:
this regex matches the variable assignment expression as a whole.
we used in all of the "whole line match" RegEx's the \A \z bounders and also parentheses for grouping.
first we look for the variable name which is described above (the previous regex).
then after a "=" char, we look for a variable value or a variable name which are also described above.
and in the end of the line  must be ";" (assuming all of the parts can include zero or more white spaces).
